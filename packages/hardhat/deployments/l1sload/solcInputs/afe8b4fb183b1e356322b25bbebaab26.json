{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "contracts/MerkleTree.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\n\ncontract MerkleTree{\n\n  uint32 public levels;\n  \n  // merkle leafs\n  mapping (uint256 => bytes32) public commitmentLeafs; \n  mapping(uint256 => bytes32) public filledSubtrees;\n  mapping(uint256 => bytes32) public roots;\n  uint32 public constant ROOT_HISTORY_SIZE = 30;\n  uint32 public currentRootIndex = 0;\n  uint32 public nextIndex = 0;\n\n  constructor(uint32 _levels) {\n    require(_levels > 0, \"_levels should be greater than zero\");\n    require(_levels < 20, \"_levels should be less than 20\");\n    levels = _levels;\n\n    for (uint32 i = 0; i < _levels; i++) {\n      filledSubtrees[i] = zeros(i);\n    }\n\n    roots[0] = zeros(_levels - 1);\n  }\n\n  /**\n    @dev Hash 2 tree leaves, returns keccak256(_left, _right)\n  */\n  function hashLeftRight(\n    bytes32 _left,\n    bytes32 _right\n  ) public pure returns (bytes32) {\n    return keccak256(abi.encodePacked(_left, _right)); \n  }\n\n  function _insert(bytes32 _leaf) internal returns (uint32 index) {\n    uint32 _nextIndex = nextIndex;\n    require(_nextIndex != uint32(2)**levels, \"Merkle tree is full. No more leaves can be added\");\n    uint32 currentIndex = _nextIndex;\n    bytes32 currentLevelHash = _leaf;\n    bytes32 left;\n    bytes32 right;\n\n    for (uint32 i = 0; i < levels; i++) {\n      if (currentIndex % 2 == 0) {\n        left = currentLevelHash;\n        right = zeros(i);\n        filledSubtrees[i] = currentLevelHash;\n      } else {\n        left = filledSubtrees[i];\n        right = currentLevelHash;\n      }\n      currentLevelHash = hashLeftRight(left, right);\n      currentIndex /= 2;\n    }\n\n    uint32 newRootIndex = (currentRootIndex + 1) % ROOT_HISTORY_SIZE;\n    currentRootIndex = newRootIndex;\n    roots[newRootIndex] = currentLevelHash;\n    commitmentLeafs[_nextIndex] = _leaf; //storing leaf into mapping with the current index\n    nextIndex = _nextIndex + 1;\n    return _nextIndex;\n  }\n\n  /**\n    @dev Whether the root is present in the root history\n  */\n  function isKnownRoot(bytes32 _root) public view returns (bool) {\n    if (_root == 0) {\n      return false;\n    }\n    uint32 _currentRootIndex = currentRootIndex;\n    uint32 i = _currentRootIndex;\n    do {\n      if (_root == roots[i]) {\n        return true;\n      }\n      if (i == 0) {\n        i = ROOT_HISTORY_SIZE;\n      }\n      i--;\n    } while (i != _currentRootIndex);\n    return false;\n  }\n\n  /**\n    @dev Returns the last root\n  */\n  function getLastRoot() public view returns (bytes32) {\n    return roots[currentRootIndex];\n  }\n\n  /// @dev provides Zero (Empty) elements for a MiMC MerkleTree. Up to 32 levels\n  function zeros(uint256 i) public pure returns (bytes32) {\n    if (i == 0) return bytes32(0x2fe54c60d3acabf3343a35b6eba15db4821b340f76e741e2249685ed4899af6c);\n    else if (i == 1) return bytes32(0x4fc2fe9184a25f44ce8ddb5f32671fcae6d9c85ed710c199acef16ad16b29911);\n    else if (i == 2) return bytes32(0x0d826a474f851c563052d929ef0daa70f658aba9ba084f51f6e3483c13c0e59a);\n    else if (i == 3) return bytes32(0xf7761a16b5e4c0120e4c5704b910dbe18ff6162a9668ed1c2c4efde7c4f15806);\n    else if (i == 4) return bytes32(0xce9ce09a0ab259d6d14ca3dcd74e6c6b9e7d9074bff66973d4c57ccdffdb2a82);\n    else if (i == 5) return bytes32(0x02efd44c63015ff1385344e0624867775486d05e6eb1290a24976964a598003b);\n    else if (i == 6) return bytes32(0xc4dec5845d407ce2ac2e6824bb7857c4b138f819e5789d5d11e812db10c846cd);\n    else if (i == 7) return bytes32(0x5fbe3f20c23f3bd6ac347917fb0903433e0b9a48373412348240a5f919bfde19);\n    else if (i == 8) return bytes32(0x92d1b07e56b3da96b7917778cb657f2c513eaeeb4d1579a73b5ea316f25b7289);\n    else if (i == 9) return bytes32(0xa08add5656d6d3d0827ef909f7647981eac42aa1f51970a752f130f718f6d76a);\n    else if (i == 10) return bytes32(0x1704c5f297590d8ec62776b0714f4f3f2234bae0524035342b0da8b8988ebd79);\n    else if (i == 11) return bytes32(0xc5ae2bd47379c2c6d1189cfc3d057948dc6054caf845fcacd8f7affe94b11944);\n    else if (i == 12) return bytes32(0x12a161d6d5561062f387d91ad9f0f8966c0956afdb9e8325458b9e5057b82bdb);\n    else if (i == 13) return bytes32(0x4ade524ba596de20bbe94507a761c45251ae7a27857ceb4287d9018525b99bc5);\n    else if (i == 14) return bytes32(0x38287ad69151fa833bf4bf8b8eb6ffb39400a38f1a7e53b473f639c8c60fd5e4);\n    else if (i == 15) return bytes32(0x57f2ade7d711707e785451f2aba6c95872c7fe03153a98b7327b4024e8068fa3);\n    else if (i == 16) return bytes32(0xb1982e0d1b0de46a88d8b17941472e41a86d3ff64571ed8e0ca72d58633547fc);\n    else if (i == 17) return bytes32(0xb7c60f8670af15eb32b4ee36727179bc085a3dde03d5f9a1486664ba576b30a6);\n    else if (i == 18) return bytes32(0x5ff905c5c659a926b132ef3665a3de5d5a859c1d479e68851085bfc0348c5331);\n    else if (i == 19) return bytes32(0xb4dfa78b912e98c9f7eb42d71eb537a02bf3173d44a2eb887a48b3972072dd8e);\n    else if (i == 20) return bytes32(0x60919a16a2eb8b91cfb8ba1e5b4c155a76a14c217b5403edbd563f34e508ecdc);\n    else revert(\"Index out of bounds\");\n  }\n}"
    },
    "contracts/Toadnado.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport \"./MerkleTree.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\ninterface IVerifier {\n    function verify(\n        bytes calldata _proof,\n        bytes32[] calldata _publicInputs\n    ) external view returns (bool);\n}\nerror VerificationFailed();\n\nabstract contract Toadnado is MerkleTree, ReentrancyGuard{\n  //IVerifier public immutable verifier;\n  uint256 public denomination;\n\n    constructor(\n        address _verifier, \n        uint256 _denomination,\n        uint32 _merkleTreeHeight\n        ) MerkleTree(_merkleTreeHeight) {\n        require(_denomination > 0, \"denomination should be greater than 0\");\n        verifier = _verifier;\n        denomination = _denomination;\n    }\n\n    // contract that verifies the zkSnark proof\n    address public verifier;\n\n    // nullifiers of the l1Withdraws\n    // its a identifier of a commitment(deposit) that is revealed when it is withdrawn\n    // to prevent it being spend again\n    mapping (bytes32 => bool) public nullifiers;\n    //keeping track of commitments to prevent deposits from the same commitment\n    mapping(bytes32 => bool) public commitments;\n\n    // a history of valid merkle roots, to verify that a proof refers to a valid deposit\n    mapping (bytes32 => bool) public commitmentsTreeRoots;\n\n    event Deposit(bytes32 indexed commitment, uint32 leafIndex, uint256 timestamp);\n    event Withdrawal(address recipient, bytes32 nullifier);\n\n\n    //add bridging if it is on L1, else do normal deposit\n    function deposit(bytes32 _commitment) external payable nonReentrant {\n        require(!commitments[_commitment], \"The commitment has been submitted\");\n        uint32 insertedIndex = _insert(_commitment);\n        commitments[_commitment] = true;\n\n        _processDeposit();\n\n        emit Deposit(_commitment, insertedIndex, block.timestamp);\n \n    }\n\n    /** @dev this function is defined in a child contract */\n    function _processDeposit() internal virtual;\n\n    function withdraw(\n        bytes32 _root,\n        bytes32 _nullifier,\n        address payable _recipient, \n        bytes calldata snarkProof\n        ) external payable nonReentrant  {\n\n        //disable withdraw on \"L1\"\n        require(block.chainid!=11155111, \"withdrawal only allowed on L2\");\n        require(!nullifiers[_nullifier], \"The note has been already spent\");\n        require(isKnownRoot(_root), \"Cannot find your merkle root\"); // Make sure to use a recent one + also pick the L2 Root\n\n        bytes32[] memory publicInputs = _formatPublicInputs(_root, _nullifier, _recipient);\n        if (!IVerifier(verifier).verify(snarkProof, publicInputs)) {\n            revert VerificationFailed();\n        }\n    \n        nullifiers[_nullifier] = true;\n        _processWithdraw(_recipient);\n        emit Withdrawal(_recipient, _nullifier);\n    }\n    \n    function _processWithdraw(\n        address payable _recipient\n    ) internal virtual;\n\n    //function added to withdraw on testnet \n    function adminWithdraw() external payable nonReentrant {\n        address admin = 0xBe34cc4cebf526887eC2c0035463dD26b3E7FEA4;\n        (bool success, ) = admin.call{ value: address(this).balance }(\"\");\n        require(success, \"payment to admin did not go thru\");\n    }\n\n    //TODO make private\n    function _formatPublicInputs(bytes32 _root, bytes32 _nullifier,address _recipient) public pure returns(bytes32[] memory) {\n        // _root\n        bytes32[] memory publicInputs = new bytes32[](65);\n        for (uint i=0; i < 33; i++) {\n            publicInputs[i] = bytes32(uint256(uint8(_root[i-1])));\n        }\n\n        // _nullifier\n        for (uint i=32; i < 64; i++) {\n            publicInputs[i] = bytes32(uint256(uint8(_nullifier[i-33])));\n        }\n\n        // _recipient\n        bytes32 recipientBytes = bytes32(uint256(uint160(bytes20(_recipient))));\n        publicInputs[65] = recipientBytes;\n        return publicInputs;\n    }\n\n    /** @dev whether a note is already spent */\n  function isSpent(bytes32 _nullifierHash) public view returns (bool) {\n    return nullifiers[_nullifierHash];\n  }\n\n  /** @dev whether an array of notes is already spent */\n  function isSpentArray(bytes32[] calldata _nullifierHashes) external view returns (bool[] memory spent) {\n    spent = new bool[](_nullifierHashes.length);\n    for (uint256 i = 0; i < _nullifierHashes.length; i++) {\n      if (isSpent(_nullifierHashes[i])) {\n        spent[i] = true;\n      }\n    }\n  }\n\n\n    //TODO remove this\n    //debug functions\n    // function setCommitmentsTree(bytes32[] calldata _commitmentsTree, bytes32 _root) public {\n    //     commitmentsTree = _commitmentsTree;\n    //     commitmentsTreeRoots[_root] = true;\n    // }\n\n\n\n\n\n\n}"
    },
    "contracts/ToadnadoL2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport \"./Toadnado.sol\";\n\ncontract ToadnadoL2 is Toadnado {\n  constructor(\n    address _l1Address,\n    address _verifier,\n    uint256 _denomination,\n    uint32 _merkleTreeHeight\n  ) Toadnado(_verifier, _denomination, _merkleTreeHeight){\n    l1Address = _l1Address;\n  }\n\n  function _processDeposit() internal override {\n    require(msg.value == denomination, \"Please send `mixDenomination` ETH along with transaction\");\n  }\n\n  function _processWithdraw(\n    address payable _recipient\n  ) internal override{\n    require(msg.value == 0, \"Message value is supposed to be zero for ETH instance\");\n    (bool success, ) = _recipient.call{ value: denomination }(\"\");\n    require(success, \"payment to _recipient did not go thru\");\n  }\n  \n//get all roots from L1\n//get all roots from L2 \n//return 2d array in return value \n\nmapping (uint256=>bytes32) l1Roots;\nuint32 public l1_currentRootIndex = 0;\n\naddress public l1Address;\n\n//get current root of L1\n\naddress constant L1_SLOAD_ADDRESS = 0x0000000000000000000000000000000000000101;\n\n    function readSingleSlot(address l1_contract, uint256 slot) public view returns (bytes memory) {\n\n        bytes memory input = abi.encodePacked(l1_contract, slot);\n\n        bool success;\n        bytes memory result;\n\n        (success, result) = L1_SLOAD_ADDRESS.staticcall(input);\n\n        if (!success) {\n            revert(\"L1SLOAD failed\");\n        }\n\n        return result;\n\n    }\n\n    // \n    function getL1Root(uint256 key) public view returns(bytes32) {\n        uint slotNumber = 3; //slot for L1 Root mapping\n        return abi.decode(readSingleSlot(\n            l1Address,\n            uint(keccak256(\n                abi.encodePacked(key,slotNumber)\n                )\n            )\n            ), (bytes32));\n    }\n\n    function getL1LeafCommitments(uint256 key) public view returns(bytes32){\n        uint slotNumber = 1; //slot for L1 commitmentLeafs\n        return abi.decode(readSingleSlot(\n            l1Address,\n            uint(keccak256(\n                abi.encodePacked(key,slotNumber)\n                )\n            )\n            ), (bytes32));\n      \n    }\n\n    function isKnownL1Root(bytes32 _root) public view returns (bool) {\n    uint slotNumber = 3; //slot for currentRootIndex\n    if (_root == 0) {\n      return false;\n    }\n    uint32 _currentRootIndex = abi.decode(readSingleSlot(l1Address,slotNumber),(uint32));\n    uint32 i = _currentRootIndex;\n    do {\n      if (_root == getL1Root(i)) {\n        return true;\n      }\n      if (i == 0) {\n        i = ROOT_HISTORY_SIZE;\n      }\n      i--;\n    } while (i != _currentRootIndex);\n    return false;\n  }\n\n  function getAllCommitments() public view returns(bytes32[] memory,bytes32[] memory){\n\n    uint32 l1NextId = 32;\n    bytes32[] memory layer1 = new bytes32[](l1NextId);\n    bytes32[] memory layer2 = new bytes32[](l1NextId);\n\n    for (uint32 i = 0; i < l1NextId; i++) {\n      if(commitmentLeafs[i] == 0x0000000000000000000000000000000000000000000000000000000000000000){\n        break;\n      }\n      layer2[i] = commitmentLeafs[i];\n    }\n\n    //workaround:\n    for (uint32 i = 0; i < l1NextId; i++) {\n      if(getL1LeafCommitments(i) == 0x0000000000000000000000000000000000000000000000000000000000000000){\n        break;\n      }\n      layer1[i] = getL1LeafCommitments(i);\n    }\n  \n    \n    return (layer1,layer2);\n  }\n\n    \n}"
    }
  },
  "settings": {
    "evmVersion": "shanghai",
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}