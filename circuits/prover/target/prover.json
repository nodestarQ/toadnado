{"noir_version":"0.30.0+af57471035e4fa7eaffa71693219df6d029dbcde","hash":16480228863985836411,"abi":{"parameters":[{"name":"root","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"nullifierHash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"recipient","type":{"kind":"field"},"visibility":"public"},{"name":"chainId","type":{"kind":"field"},"visibility":"public"},{"name":"nullifierHashPreImage","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"secret","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"hash_path","type":{"kind":"array","length":5,"type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},"visibility":"private"},{"name":"hash_path_bools","type":{"kind":"array","length":5,"type":{"kind":"boolean"}},"visibility":"private"},{"name":"root_other_layer","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"root_other_is_right","type":{"kind":"boolean"},"visibility":"private"}],"param_witnesses":{"chainId":[{"start":65,"end":66}],"hash_path":[{"start":130,"end":290}],"hash_path_bools":[{"start":290,"end":295}],"nullifierHash":[{"start":32,"end":64}],"nullifierHashPreImage":[{"start":66,"end":98}],"recipient":[{"start":64,"end":65}],"root":[{"start":0,"end":32}],"root_other_is_right":[{"start":327,"end":328}],"root_other_layer":[{"start":295,"end":327}],"secret":[{"start":98,"end":130}]},"return_type":null,"return_witnesses":[],"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"22":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x âˆˆ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field.nr"},"30":{"source":"mod hash;\nmod aes128;\nmod array;\nmod slice;\nmod merkle;\nmod schnorr;\nmod ecdsa_secp256k1;\nmod ecdsa_secp256r1;\nmod eddsa;\nmod embedded_curve_ops;\nmod sha256;\nmod sha512;\nmod field;\nmod ec;\nmod unsafe;\nmod collections;\nmod compat;\nmod convert;\nmod option;\nmod string;\nmod test;\nmod cmp;\nmod ops;\nmod default;\nmod prelude;\nmod uint128;\nmod bigint;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained pub fn print<T>(input: T) {\n    print_oracle(false, input);\n}\n\nunconstrained pub fn println<T>(input: T) {\n    print_oracle(true, input);\n}\n\n#[foreign(recursive_aggregation)]\npub fn verify_proof<N>(verification_key: [Field], proof: [Field], public_inputs: [Field], key_hash: Field) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n// from_field and as_field are private since they are not valid for every type.\n// `as` should be the default for users to cast between primitive types, and in the future\n// traits can be used to work with generic types.\n#[builtin(from_field)]\nfn from_field<T>(x: Field) -> T {}\n\n#[builtin(as_field)]\nfn as_field<T>(x: T) -> Field {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) + crate::as_field(y))\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T {\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    crate::from_field(crate::as_field(x) + 340282366920938463463374607431768211456 - crate::as_field(y))\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) * crate::as_field(y))\n}\n","path":"std/lib.nr"},"40":{"source":"impl<T> [T] {\n    #[builtin(array_len)]\n    pub fn len(self) -> u64 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the \n    /// original unmodified slice. \n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements \n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u64, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and \n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u64) -> (Self, T) {}\n\n    // Append each element of the `other` slice to the end of `self`.\n    // This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<N>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::unsafe::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n}\n","path":"std/slice.nr"},"46":{"source":"use dep::std;\n\nglobal TREE_DEPTH = 5;\n\n\nfn joinArrays<I,J>(arrays: [[u8;J];I]) -> [u8] {\n    //TODO find out if doing without slice is faster?\n    let mut resSlice: [u8] = [];\n    for index in 0 .. arrays.len() {\n        resSlice = resSlice.append(arrays[index].as_slice());\n        \n    } \n    resSlice\n}\n\nfn hashKeccak2(first: [u8;32], second: [u8;32]) -> [u8;32] {\n    let mut preImage: [u8;64] = [0;64];\n\n    for i in 0 .. 32 {\n        preImage[i] = first[i];\n        \n    }\n    for i in 0 .. 32 {\n        preImage[i+32] = second[i];\n        \n    }\n    std::hash::keccak256(preImage,64)\n}\n\n// used merkle from noir std as example\n// https://github.com/noir-lang/noir/blob/49e1b0c0d45565f3e87469b77f2fef0c283f6ea1/noir_stdlib/src/merkle.nr#L5\n// Returns the merkle root of the tree from the provided leaf hash, \n// its hashpath and hash_path_bools to indicate wether to hash left or right\nfn compute_merkle_root<N>(\n    leaf_hash: [u8;32], \n    hash_path: [ [u8;32]; N], \n    hash_path_bools: [bool; N]\n    ) -> [u8;32] {\n\n    let n = hash_path.len();\n    let mut current = leaf_hash;\n    for i in 0..n {\n        let hash_right = hash_path_bools[i];\n        if hash_right {\n            current = hashKeccak2(hash_path[i], current);\n        } else {\n            current = hashKeccak2(current, hash_path[i]);\n        };\n    }\n    current\n}\n\nfn commitmentHasher(nullifierHashPreImage: [u8;32], secret: [u8;32], chainId: Field) -> ([u8;32],[u8;32]) {\n    let computedNullifierHash: [u8;32] = std::hash::keccak256(nullifierHashPreImage,32);\n    let preImage: [u8;32*3] = joinArrays([nullifierHashPreImage,secret, chainId.to_be_bytes(32).as_array()]).as_array();\n    let commitmentHash: [u8;32] = std::hash::keccak256(preImage, 32*3);\n    (commitmentHash,computedNullifierHash)\n}\n\n\nfn main(\n    // public\n    root:pub [u8;32],\n    nullifierHash:pub [u8;32], \n    recipient:pub Field, \n    chainId: pub Field,\n\n    // private\n    nullifierHashPreImage: [u8;32],\n    secret: [u8;32],\n    hash_path: [[u8;32];TREE_DEPTH],\n    hash_path_bools:  [bool; TREE_DEPTH],\n    root_other_layer: [u8;32],\n    root_other_is_right: bool // left = L1, right = L2\n\n    ) {\n    // to make sure these are set and cant change\n    assert(recipient != 0x0, \"recipient shouldnt be 0\");\n\n    let (commitmentHash, computedNullifierHash) = commitmentHasher(nullifierHashPreImage, secret, chainId);\n\n    let computed_root = compute_merkle_root(commitmentHash, hash_path, hash_path_bools);\n\n    let (root_L1, root_L2) = if root_other_is_right {\n            (computed_root, root_other_layer)\n        } else {\n            (root_other_layer, computed_root)\n        };\n    let computed_meta_root = hashKeccak2(root_L1, root_L2);\n\n\n\n    println(\"computedNullifierHash\");\n    println(computedNullifierHash);\n    println(nullifierHash);\n\n    assert(computedNullifierHash == nullifierHash, \"nullifier hash doesnt match\");\n    assert(computed_meta_root == root, \"meta_root doesnt match\");\n}\n\n#[test]\nfn test_simple_merkle_proof() {\n    \n    let hash_path = [[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20],[79,194,254,145,132,162,95,68,206,141,219,95,50,103,31,202,230,217,200,94,215,16,193,153,172,239,22,173,22,178,153,17],[13,130,106,71,79,133,28,86,48,82,217,41,239,13,170,112,246,88,171,169,186,8,79,81,246,227,72,60,19,192,229,154],[247,118,26,22,181,228,192,18,14,76,87,4,185,16,219,225,143,246,22,42,150,104,237,28,44,78,253,231,196,241,88,6],[206,156,224,154,10,178,89,214,209,76,163,220,215,78,108,107,158,125,144,116,191,246,105,115,212,197,124,205,255,219,42,130],[2,239,212,76,99,1,95,241,56,83,68,224,98,72,103,119,84,134,208,94,110,177,41,10,36,151,105,100,165,152,0,59],[196,222,197,132,93,64,124,226,172,46,104,36,187,120,87,196,177,56,248,25,229,120,157,93,17,232,18,219,16,200,70,205]];\n    let leaf = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,66,0];\n    let real_root = [218,130,62,147,72,0,144,187,88,40,196,24,198,243,240,151,71,112,62,173,29,168,116,56,198,174,231,247,158,128,233,2];\n    let hash_path_bools = [true,false,false,false,false,false,false];\n    let root = compute_merkle_root(leaf,hash_path, hash_path_bools);\n    \n    // println(\"root\");\n    // println(root);\n    assert(root == real_root);\n}\n#[test]\nfn test_commitment_hasher() {\n    //[...crypto.getRandomValues(new Uint8Array(Array(32)))]\n    let nullifierHashPreImage = [214,255,124,83,114,187,12,181,14,111,72,234,5,249,135,238,141,197,183,240,45,224,153,161,158,69,230,216,57,122,75,68];\n    let secret = [230,146,124,238,124,120,160,205,44,185,238,166,139,63,96,30,207,97,7,85,117,207,245,240,45,97,6,100,229,191,245,27];\n    let chainId = 2227728; //L1SLOAD aka L2 \n    let (commitmentHash, computedNullifierHash) = commitmentHasher(nullifierHashPreImage, secret, chainId);\n    println(\"commitmentHash\");\n    println(commitmentHash);\n    println(\"computedNullifierHash\");\n    println(computedNullifierHash);\n\n    // ethers.hexlify(new Uint8Array(computedNullifierHash))\n}\n\n\n#[test]\nfn test_main() {\n    let root: [u8;32] = [ 126, 110, 203, 158, 212, 147, 148, 125, 239, 239, 254, 80, 140, 158, 181, 10, 64, 30, 96,99, 86, 26, 58, 188, 197, 12, 248, 200, 203, 120, 238, 155 ];\n    let nullifierHash: [u8;32] = [ 206, 109, 123, 82, 130, 189, 154, 54, 97, 174, 6, 31, 238, 209, 219, 218, 78, 82, 171, 7, 59, 31, 146, 133, 190, 110, 21, 93, 156, 56, 212, 236 ];\n    let recipient: Field = 0x000000000000000000000000794464c8c91a2be4addabfdb82b6db7b1bb1dbc7;\n    let chainId = 2227728; //L1SLOAD aka L2 \n\n    let nullifierHashPreImage: [u8;32] =    [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 ];\n    let secret: [u8;32] =                   [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20 ];\n    let hash_path: [[u8;32];TREE_DEPTH] = [\n      [ 47, 229, 76, 96, 211, 172, 171, 243, 52, 58, 53, 182, 235, 161, 93, 180, 130, 27, 52, 15, 118,\n        231, 65, 226, 36, 150, 133, 237, 72, 153, 175, 108 ], [ 79, 194, 254, 145, 132, 162, 95, 68,\n        206, 141, 219, 95, 50, 103, 31, 202, 230, 217, 200, 94, 215, 16, 193, 153, 172, 239, 22, 173,\n        22, 178, 153, 17 ], [ 13, 130, 106, 71, 79, 133, 28, 86, 48, 82, 217, 41, 239, 13, 170, 112,\n        246, 88, 171, 169, 186, 8, 79, 81, 246, 227, 72, 60, 19, 192, 229, 154 ], [ 247, 118, 26, 22,\n        181, 228, 192, 18, 14, 76, 87, 4, 185, 16, 219, 225, 143, 246, 22, 42, 150, 104, 237, 28, 44,\n        78, 253, 231, 196, 241, 88, 6 ], [ 206, 156, 224, 154, 10, 178, 89, 214, 209, 76, 163, 220,\n        215, 78, 108, 107, 158, 125, 144, 116, 191, 246, 105, 115, 212, 197, 124, 205, 255, 219, 42,\n        130 ]\n    ];\n    let hash_path_bools:  [bool; TREE_DEPTH] =  [ false, false, false, false, false ];\n\n    let root_other_layer =  [ 2, 239, 212, 76, 99, 1, 95, 241, 56, 83, 68, 224, 98, 72, 103, 119, 84, 134, 208, 94, 110, 177, 41, 10, 36, 151, 105, 100, 165, 152, 0, 59 ];\n\n    let root_other_is_right = true;\n    main(\n        root,\n        nullifierHash, \n        recipient, \n        chainId,\n\n        nullifierHashPreImage,\n        secret,\n        hash_path,\n        hash_path_bools,\n        root_other_layer,\n        root_other_is_right\n    );\n\n}","path":"/home/jimjim/Desktop/toadnado/circuits/prover/src/main.nr"}},"names":["main"]}